// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bledata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct LaunchCompanionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceNamePattern: String = String()

  var singleDeviceScan: Bool = false

  var forceConfirmation: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeviceAssociationInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var macAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ScanForDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceUuids: [Uuid] = []

  var scanMode: Int32 = 0

  var requireLocationServicesEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeviceScanInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var serviceData: [ServiceDataEntry] = []

  var manufacturerData: Data = Data()

  var serviceUuids: [Uuid] = []

  var rssi: Int32 = 0

  var isConnectable: IsConnectable {
    get {return _isConnectable ?? IsConnectable()}
    set {_isConnectable = newValue}
  }
  /// Returns true if `isConnectable` has been explicitly set.
  var hasIsConnectable: Bool {return self._isConnectable != nil}
  /// Clears the value of `isConnectable`. Subsequent reads from it will return its default value.
  mutating func clearIsConnectable() {self._isConnectable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
  fileprivate var _isConnectable: IsConnectable? = nil
}

struct EstablishBondingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EstablishBondingInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: EstablishBondingInfo.BondState = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum BondState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case bondNone // = 10
    case bondBonding // = 11
    case bondBonded // = 12
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 10: self = .bondNone
      case 11: self = .bondBonding
      case 12: self = .bondBonded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .bondNone: return 10
      case .bondBonding: return 11
      case .bondBonded: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension EstablishBondingInfo.BondState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [EstablishBondingInfo.BondState] = [
    .unknown,
    .bondNone,
    .bondBonding,
    .bondBonded,
  ]
}

#endif  // swift(>=4.2)

struct ConnectToDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var servicesWithCharacteristicsToDiscover: ServicesWithCharacteristics {
    get {return _servicesWithCharacteristicsToDiscover ?? ServicesWithCharacteristics()}
    set {_servicesWithCharacteristicsToDiscover = newValue}
  }
  /// Returns true if `servicesWithCharacteristicsToDiscover` has been explicitly set.
  var hasServicesWithCharacteristicsToDiscover: Bool {return self._servicesWithCharacteristicsToDiscover != nil}
  /// Clears the value of `servicesWithCharacteristicsToDiscover`. Subsequent reads from it will return its default value.
  mutating func clearServicesWithCharacteristicsToDiscover() {self._servicesWithCharacteristicsToDiscover = nil}

  var timeoutInMs: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _servicesWithCharacteristicsToDiscover: ServicesWithCharacteristics? = nil
}

struct DeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var connectionState: Int32 = 0

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct GetDeviceNameRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeviceNameInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var deviceName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DisconnectFromDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClearGattCacheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClearGattCacheInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct NotifyCharacteristicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
}

struct NotifyNoMoreCharacteristicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
}

struct ReadCharacteristicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
}

struct CharacteristicValueInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var value: Data = Data()

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
  fileprivate var _failure: GenericFailure? = nil
}

struct WriteCharacteristicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
}

struct WriteCharacteristicInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
  fileprivate var _failure: GenericFailure? = nil
}

struct NegotiateMtuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var mtuSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NegotiateMtuInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var mtuSize: Int32 = 0

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct BleStatusInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChangeConnectionPriorityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var priority: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChangeConnectionPriorityInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct CharacteristicAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var serviceUuid: Uuid {
    get {return _serviceUuid ?? Uuid()}
    set {_serviceUuid = newValue}
  }
  /// Returns true if `serviceUuid` has been explicitly set.
  var hasServiceUuid: Bool {return self._serviceUuid != nil}
  /// Clears the value of `serviceUuid`. Subsequent reads from it will return its default value.
  mutating func clearServiceUuid() {self._serviceUuid = nil}

  var characteristicUuid: Uuid {
    get {return _characteristicUuid ?? Uuid()}
    set {_characteristicUuid = newValue}
  }
  /// Returns true if `characteristicUuid` has been explicitly set.
  var hasCharacteristicUuid: Bool {return self._characteristicUuid != nil}
  /// Clears the value of `characteristicUuid`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristicUuid() {self._characteristicUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceUuid: Uuid? = nil
  fileprivate var _characteristicUuid: Uuid? = nil
}

struct ServiceDataEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceUuid: Uuid {
    get {return _serviceUuid ?? Uuid()}
    set {_serviceUuid = newValue}
  }
  /// Returns true if `serviceUuid` has been explicitly set.
  var hasServiceUuid: Bool {return self._serviceUuid != nil}
  /// Clears the value of `serviceUuid`. Subsequent reads from it will return its default value.
  mutating func clearServiceUuid() {self._serviceUuid = nil}

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceUuid: Uuid? = nil
}

struct ServicesWithCharacteristics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [ServiceWithCharacteristics] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ServiceWithCharacteristics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceID: Uuid {
    get {return _serviceID ?? Uuid()}
    set {_serviceID = newValue}
  }
  /// Returns true if `serviceID` has been explicitly set.
  var hasServiceID: Bool {return self._serviceID != nil}
  /// Clears the value of `serviceID`. Subsequent reads from it will return its default value.
  mutating func clearServiceID() {self._serviceID = nil}

  var characteristics: [Uuid] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceID: Uuid? = nil
}

struct DiscoverServicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DiscoverServicesInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var services: [DiscoveredService] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DiscoveredService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceUuid: Uuid {
    get {return _serviceUuid ?? Uuid()}
    set {_serviceUuid = newValue}
  }
  /// Returns true if `serviceUuid` has been explicitly set.
  var hasServiceUuid: Bool {return self._serviceUuid != nil}
  /// Clears the value of `serviceUuid`. Subsequent reads from it will return its default value.
  mutating func clearServiceUuid() {self._serviceUuid = nil}

  var characteristicUuids: [Uuid] = []

  var includedServices: [DiscoveredService] = []

  var characteristics: [DiscoveredCharacteristic] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceUuid: Uuid? = nil
}

struct DiscoveredCharacteristic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristicID: Uuid {
    get {return _characteristicID ?? Uuid()}
    set {_characteristicID = newValue}
  }
  /// Returns true if `characteristicID` has been explicitly set.
  var hasCharacteristicID: Bool {return self._characteristicID != nil}
  /// Clears the value of `characteristicID`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristicID() {self._characteristicID = nil}

  var serviceID: Uuid {
    get {return _serviceID ?? Uuid()}
    set {_serviceID = newValue}
  }
  /// Returns true if `serviceID` has been explicitly set.
  var hasServiceID: Bool {return self._serviceID != nil}
  /// Clears the value of `serviceID`. Subsequent reads from it will return its default value.
  mutating func clearServiceID() {self._serviceID = nil}

  var isReadable: Bool = false

  var isWritableWithResponse: Bool = false

  var isWritableWithoutResponse: Bool = false

  var isNotifiable: Bool = false

  var isIndicatable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristicID: Uuid? = nil
  fileprivate var _serviceID: Uuid? = nil
}

struct Uuid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GenericFailure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct IsConnectable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension LaunchCompanionRequest: @unchecked Sendable {}
extension DeviceAssociationInfo: @unchecked Sendable {}
extension ScanForDevicesRequest: @unchecked Sendable {}
extension DeviceScanInfo: @unchecked Sendable {}
extension EstablishBondingRequest: @unchecked Sendable {}
extension EstablishBondingInfo: @unchecked Sendable {}
extension EstablishBondingInfo.BondState: @unchecked Sendable {}
extension ConnectToDeviceRequest: @unchecked Sendable {}
extension DeviceInfo: @unchecked Sendable {}
extension GetDeviceNameRequest: @unchecked Sendable {}
extension DeviceNameInfo: @unchecked Sendable {}
extension DisconnectFromDeviceRequest: @unchecked Sendable {}
extension ClearGattCacheRequest: @unchecked Sendable {}
extension ClearGattCacheInfo: @unchecked Sendable {}
extension NotifyCharacteristicRequest: @unchecked Sendable {}
extension NotifyNoMoreCharacteristicRequest: @unchecked Sendable {}
extension ReadCharacteristicRequest: @unchecked Sendable {}
extension CharacteristicValueInfo: @unchecked Sendable {}
extension WriteCharacteristicRequest: @unchecked Sendable {}
extension WriteCharacteristicInfo: @unchecked Sendable {}
extension NegotiateMtuRequest: @unchecked Sendable {}
extension NegotiateMtuInfo: @unchecked Sendable {}
extension BleStatusInfo: @unchecked Sendable {}
extension ChangeConnectionPriorityRequest: @unchecked Sendable {}
extension ChangeConnectionPriorityInfo: @unchecked Sendable {}
extension CharacteristicAddress: @unchecked Sendable {}
extension ServiceDataEntry: @unchecked Sendable {}
extension ServicesWithCharacteristics: @unchecked Sendable {}
extension ServiceWithCharacteristics: @unchecked Sendable {}
extension DiscoverServicesRequest: @unchecked Sendable {}
extension DiscoverServicesInfo: @unchecked Sendable {}
extension DiscoveredService: @unchecked Sendable {}
extension DiscoveredCharacteristic: @unchecked Sendable {}
extension Uuid: @unchecked Sendable {}
extension GenericFailure: @unchecked Sendable {}
extension IsConnectable: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension LaunchCompanionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LaunchCompanionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceNamePattern"),
    2: .same(proto: "singleDeviceScan"),
    3: .same(proto: "forceConfirmation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceNamePattern) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.singleDeviceScan) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.forceConfirmation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceNamePattern.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceNamePattern, fieldNumber: 1)
    }
    if self.singleDeviceScan != false {
      try visitor.visitSingularBoolField(value: self.singleDeviceScan, fieldNumber: 2)
    }
    if self.forceConfirmation != false {
      try visitor.visitSingularBoolField(value: self.forceConfirmation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LaunchCompanionRequest, rhs: LaunchCompanionRequest) -> Bool {
    if lhs.deviceNamePattern != rhs.deviceNamePattern {return false}
    if lhs.singleDeviceScan != rhs.singleDeviceScan {return false}
    if lhs.forceConfirmation != rhs.forceConfirmation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceAssociationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceAssociationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "macAddress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.macAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.macAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.macAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceAssociationInfo, rhs: DeviceAssociationInfo) -> Bool {
    if lhs.macAddress != rhs.macAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ScanForDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ScanForDevicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuids"),
    2: .same(proto: "scanMode"),
    3: .same(proto: "requireLocationServicesEnabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serviceUuids) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.scanMode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requireLocationServicesEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceUuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceUuids, fieldNumber: 1)
    }
    if self.scanMode != 0 {
      try visitor.visitSingularInt32Field(value: self.scanMode, fieldNumber: 2)
    }
    if self.requireLocationServicesEnabled != false {
      try visitor.visitSingularBoolField(value: self.requireLocationServicesEnabled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ScanForDevicesRequest, rhs: ScanForDevicesRequest) -> Bool {
    if lhs.serviceUuids != rhs.serviceUuids {return false}
    if lhs.scanMode != rhs.scanMode {return false}
    if lhs.requireLocationServicesEnabled != rhs.requireLocationServicesEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceScanInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceScanInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "failure"),
    4: .same(proto: "serviceData"),
    6: .same(proto: "manufacturerData"),
    7: .same(proto: "serviceUuids"),
    5: .same(proto: "rssi"),
    8: .same(proto: "isConnectable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.serviceData) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.rssi) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.manufacturerData) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.serviceUuids) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._isConnectable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.serviceData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceData, fieldNumber: 4)
    }
    if self.rssi != 0 {
      try visitor.visitSingularInt32Field(value: self.rssi, fieldNumber: 5)
    }
    if !self.manufacturerData.isEmpty {
      try visitor.visitSingularBytesField(value: self.manufacturerData, fieldNumber: 6)
    }
    if !self.serviceUuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceUuids, fieldNumber: 7)
    }
    try { if let v = self._isConnectable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceScanInfo, rhs: DeviceScanInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.serviceData != rhs.serviceData {return false}
    if lhs.manufacturerData != rhs.manufacturerData {return false}
    if lhs.serviceUuids != rhs.serviceUuids {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs._isConnectable != rhs._isConnectable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EstablishBondingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EstablishBondingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EstablishBondingRequest, rhs: EstablishBondingRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EstablishBondingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EstablishBondingInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EstablishBondingInfo, rhs: EstablishBondingInfo) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EstablishBondingInfo.BondState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    10: .same(proto: "BOND_NONE"),
    11: .same(proto: "BOND_BONDING"),
    12: .same(proto: "BOND_BONDED"),
  ]
}

extension ConnectToDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConnectToDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "servicesWithCharacteristicsToDiscover"),
    3: .same(proto: "timeoutInMs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._servicesWithCharacteristicsToDiscover) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timeoutInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try { if let v = self._servicesWithCharacteristicsToDiscover {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timeoutInMs != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutInMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ConnectToDeviceRequest, rhs: ConnectToDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._servicesWithCharacteristicsToDiscover != rhs._servicesWithCharacteristicsToDiscover {return false}
    if lhs.timeoutInMs != rhs.timeoutInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "connectionState"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.connectionState) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.connectionState != 0 {
      try visitor.visitSingularInt32Field(value: self.connectionState, fieldNumber: 2)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.connectionState != rhs.connectionState {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetDeviceNameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetDeviceNameRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetDeviceNameRequest, rhs: GetDeviceNameRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceNameInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceNameInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "deviceName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceNameInfo, rhs: DeviceNameInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DisconnectFromDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DisconnectFromDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DisconnectFromDeviceRequest, rhs: DisconnectFromDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClearGattCacheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClearGattCacheRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClearGattCacheRequest, rhs: ClearGattCacheRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClearGattCacheInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClearGattCacheInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClearGattCacheInfo, rhs: ClearGattCacheInfo) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotifyCharacteristicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NotifyCharacteristicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NotifyCharacteristicRequest, rhs: NotifyCharacteristicRequest) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotifyNoMoreCharacteristicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NotifyNoMoreCharacteristicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NotifyNoMoreCharacteristicRequest, rhs: NotifyNoMoreCharacteristicRequest) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReadCharacteristicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ReadCharacteristicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ReadCharacteristicRequest, rhs: ReadCharacteristicRequest) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CharacteristicValueInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CharacteristicValueInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
    2: .same(proto: "value"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CharacteristicValueInfo, rhs: CharacteristicValueInfo) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.value != rhs.value {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WriteCharacteristicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WriteCharacteristicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WriteCharacteristicRequest, rhs: WriteCharacteristicRequest) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WriteCharacteristicInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WriteCharacteristicInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WriteCharacteristicInfo, rhs: WriteCharacteristicInfo) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NegotiateMtuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NegotiateMtuRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "mtuSize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.mtuSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.mtuSize != 0 {
      try visitor.visitSingularInt32Field(value: self.mtuSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NegotiateMtuRequest, rhs: NegotiateMtuRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.mtuSize != rhs.mtuSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NegotiateMtuInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NegotiateMtuInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "mtuSize"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.mtuSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.mtuSize != 0 {
      try visitor.visitSingularInt32Field(value: self.mtuSize, fieldNumber: 2)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NegotiateMtuInfo, rhs: NegotiateMtuInfo) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.mtuSize != rhs.mtuSize {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BleStatusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BleStatusInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BleStatusInfo, rhs: BleStatusInfo) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChangeConnectionPriorityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChangeConnectionPriorityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "priority"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.priority) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.priority != 0 {
      try visitor.visitSingularInt32Field(value: self.priority, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChangeConnectionPriorityRequest, rhs: ChangeConnectionPriorityRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.priority != rhs.priority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChangeConnectionPriorityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChangeConnectionPriorityInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChangeConnectionPriorityInfo, rhs: ChangeConnectionPriorityInfo) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CharacteristicAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CharacteristicAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "serviceUuid"),
    3: .same(proto: "characteristicUuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._serviceUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._characteristicUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try { if let v = self._serviceUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._characteristicUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CharacteristicAddress, rhs: CharacteristicAddress) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._serviceUuid != rhs._serviceUuid {return false}
    if lhs._characteristicUuid != rhs._characteristicUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServiceDataEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServiceDataEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuid"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceUuid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServiceDataEntry, rhs: ServiceDataEntry) -> Bool {
    if lhs._serviceUuid != rhs._serviceUuid {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServicesWithCharacteristics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServicesWithCharacteristics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServicesWithCharacteristics, rhs: ServicesWithCharacteristics) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServiceWithCharacteristics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServiceWithCharacteristics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceId"),
    2: .same(proto: "characteristics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServiceWithCharacteristics, rhs: ServiceWithCharacteristics) -> Bool {
    if lhs._serviceID != rhs._serviceID {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DiscoverServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DiscoverServicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DiscoverServicesRequest, rhs: DiscoverServicesRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DiscoverServicesInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DiscoverServicesInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DiscoverServicesInfo, rhs: DiscoverServicesInfo) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DiscoveredService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DiscoveredService"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuid"),
    2: .same(proto: "characteristicUuids"),
    3: .same(proto: "includedServices"),
    4: .same(proto: "characteristics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceUuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.characteristicUuids) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.includedServices) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.characteristicUuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristicUuids, fieldNumber: 2)
    }
    if !self.includedServices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.includedServices, fieldNumber: 3)
    }
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DiscoveredService, rhs: DiscoveredService) -> Bool {
    if lhs._serviceUuid != rhs._serviceUuid {return false}
    if lhs.characteristicUuids != rhs.characteristicUuids {return false}
    if lhs.includedServices != rhs.includedServices {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DiscoveredCharacteristic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DiscoveredCharacteristic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristicId"),
    2: .same(proto: "serviceId"),
    3: .same(proto: "isReadable"),
    4: .same(proto: "isWritableWithResponse"),
    5: .same(proto: "isWritableWithoutResponse"),
    6: .same(proto: "isNotifiable"),
    7: .same(proto: "isIndicatable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristicID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._serviceID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isReadable) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isWritableWithResponse) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isWritableWithoutResponse) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isNotifiable) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isIndicatable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characteristicID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._serviceID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isReadable != false {
      try visitor.visitSingularBoolField(value: self.isReadable, fieldNumber: 3)
    }
    if self.isWritableWithResponse != false {
      try visitor.visitSingularBoolField(value: self.isWritableWithResponse, fieldNumber: 4)
    }
    if self.isWritableWithoutResponse != false {
      try visitor.visitSingularBoolField(value: self.isWritableWithoutResponse, fieldNumber: 5)
    }
    if self.isNotifiable != false {
      try visitor.visitSingularBoolField(value: self.isNotifiable, fieldNumber: 6)
    }
    if self.isIndicatable != false {
      try visitor.visitSingularBoolField(value: self.isIndicatable, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DiscoveredCharacteristic, rhs: DiscoveredCharacteristic) -> Bool {
    if lhs._characteristicID != rhs._characteristicID {return false}
    if lhs._serviceID != rhs._serviceID {return false}
    if lhs.isReadable != rhs.isReadable {return false}
    if lhs.isWritableWithResponse != rhs.isWritableWithResponse {return false}
    if lhs.isWritableWithoutResponse != rhs.isWritableWithoutResponse {return false}
    if lhs.isNotifiable != rhs.isNotifiable {return false}
    if lhs.isIndicatable != rhs.isIndicatable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Uuid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Uuid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Uuid, rhs: Uuid) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GenericFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GenericFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GenericFailure, rhs: GenericFailure) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IsConnectable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IsConnectable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IsConnectable, rhs: IsConnectable) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
