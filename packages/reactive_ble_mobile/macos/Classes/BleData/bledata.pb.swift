// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: bledata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ScanForDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceUuids: [Uuid] = []

  var scanMode: Int32 = 0

  var requireLocationServicesEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeviceScanInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var serviceData: [ServiceDataEntry] = []

  var manufacturerData: Data = Data()

  var serviceUuids: [Uuid] = []

  var rssi: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct ConnectToDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var servicesWithCharacteristicsToDiscover: ServicesWithCharacteristics {
    get {return _servicesWithCharacteristicsToDiscover ?? ServicesWithCharacteristics()}
    set {_servicesWithCharacteristicsToDiscover = newValue}
  }
  /// Returns true if `servicesWithCharacteristicsToDiscover` has been explicitly set.
  var hasServicesWithCharacteristicsToDiscover: Bool {return self._servicesWithCharacteristicsToDiscover != nil}
  /// Clears the value of `servicesWithCharacteristicsToDiscover`. Subsequent reads from it will return its default value.
  mutating func clearServicesWithCharacteristicsToDiscover() {self._servicesWithCharacteristicsToDiscover = nil}

  var timeoutInMs: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _servicesWithCharacteristicsToDiscover: ServicesWithCharacteristics? = nil
}

struct DeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var connectionState: Int32 = 0

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct DisconnectFromDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClearGattCacheRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClearGattCacheInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct NotifyCharacteristicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
}

struct NotifyNoMoreCharacteristicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
}

struct ReadCharacteristicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
}

struct CharacteristicValueInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var value: Data = Data()

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
  fileprivate var _failure: GenericFailure? = nil
}

struct WriteCharacteristicRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
}

struct WriteCharacteristicInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristic: CharacteristicAddress {
    get {return _characteristic ?? CharacteristicAddress()}
    set {_characteristic = newValue}
  }
  /// Returns true if `characteristic` has been explicitly set.
  var hasCharacteristic: Bool {return self._characteristic != nil}
  /// Clears the value of `characteristic`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristic() {self._characteristic = nil}

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristic: CharacteristicAddress? = nil
  fileprivate var _failure: GenericFailure? = nil
}

struct NegotiateMtuRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var mtuSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NegotiateMtuInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var mtuSize: Int32 = 0

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct BleStatusInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChangeConnectionPriorityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var priority: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChangeConnectionPriorityInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var failure: GenericFailure {
    get {return _failure ?? GenericFailure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: GenericFailure? = nil
}

struct CharacteristicAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var serviceUuid: Uuid {
    get {return _serviceUuid ?? Uuid()}
    set {_serviceUuid = newValue}
  }
  /// Returns true if `serviceUuid` has been explicitly set.
  var hasServiceUuid: Bool {return self._serviceUuid != nil}
  /// Clears the value of `serviceUuid`. Subsequent reads from it will return its default value.
  mutating func clearServiceUuid() {self._serviceUuid = nil}

  var characteristicUuid: Uuid {
    get {return _characteristicUuid ?? Uuid()}
    set {_characteristicUuid = newValue}
  }
  /// Returns true if `characteristicUuid` has been explicitly set.
  var hasCharacteristicUuid: Bool {return self._characteristicUuid != nil}
  /// Clears the value of `characteristicUuid`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristicUuid() {self._characteristicUuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceUuid: Uuid? = nil
  fileprivate var _characteristicUuid: Uuid? = nil
}

struct ServiceDataEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceUuid: Uuid {
    get {return _serviceUuid ?? Uuid()}
    set {_serviceUuid = newValue}
  }
  /// Returns true if `serviceUuid` has been explicitly set.
  var hasServiceUuid: Bool {return self._serviceUuid != nil}
  /// Clears the value of `serviceUuid`. Subsequent reads from it will return its default value.
  mutating func clearServiceUuid() {self._serviceUuid = nil}

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceUuid: Uuid? = nil
}

struct ServicesWithCharacteristics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [ServiceWithCharacteristics] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ServiceWithCharacteristics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceID: Uuid {
    get {return _serviceID ?? Uuid()}
    set {_serviceID = newValue}
  }
  /// Returns true if `serviceID` has been explicitly set.
  var hasServiceID: Bool {return self._serviceID != nil}
  /// Clears the value of `serviceID`. Subsequent reads from it will return its default value.
  mutating func clearServiceID() {self._serviceID = nil}

  var characteristics: [Uuid] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceID: Uuid? = nil
}

struct DiscoverServicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DiscoverServicesInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var services: [DiscoveredService] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DiscoveredService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceUuid: Uuid {
    get {return _serviceUuid ?? Uuid()}
    set {_serviceUuid = newValue}
  }
  /// Returns true if `serviceUuid` has been explicitly set.
  var hasServiceUuid: Bool {return self._serviceUuid != nil}
  /// Clears the value of `serviceUuid`. Subsequent reads from it will return its default value.
  mutating func clearServiceUuid() {self._serviceUuid = nil}

  var characteristicUuids: [Uuid] = []

  var includedServices: [DiscoveredService] = []

  var characteristics: [DiscoveredCharacteristic] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serviceUuid: Uuid? = nil
}

struct DiscoveredCharacteristic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characteristicID: Uuid {
    get {return _characteristicID ?? Uuid()}
    set {_characteristicID = newValue}
  }
  /// Returns true if `characteristicID` has been explicitly set.
  var hasCharacteristicID: Bool {return self._characteristicID != nil}
  /// Clears the value of `characteristicID`. Subsequent reads from it will return its default value.
  mutating func clearCharacteristicID() {self._characteristicID = nil}

  var serviceID: Uuid {
    get {return _serviceID ?? Uuid()}
    set {_serviceID = newValue}
  }
  /// Returns true if `serviceID` has been explicitly set.
  var hasServiceID: Bool {return self._serviceID != nil}
  /// Clears the value of `serviceID`. Subsequent reads from it will return its default value.
  mutating func clearServiceID() {self._serviceID = nil}

  var isReadable: Bool = false

  var isWritableWithResponse: Bool = false

  var isWritableWithoutResponse: Bool = false

  var isNotifiable: Bool = false

  var isIndicatable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _characteristicID: Uuid? = nil
  fileprivate var _serviceID: Uuid? = nil
}

struct Uuid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GenericFailure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ScanForDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ScanForDevicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuids"),
    2: .same(proto: "scanMode"),
    3: .same(proto: "requireLocationServicesEnabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serviceUuids) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.scanMode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requireLocationServicesEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceUuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceUuids, fieldNumber: 1)
    }
    if self.scanMode != 0 {
      try visitor.visitSingularInt32Field(value: self.scanMode, fieldNumber: 2)
    }
    if self.requireLocationServicesEnabled != false {
      try visitor.visitSingularBoolField(value: self.requireLocationServicesEnabled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ScanForDevicesRequest, rhs: ScanForDevicesRequest) -> Bool {
    if lhs.serviceUuids != rhs.serviceUuids {return false}
    if lhs.scanMode != rhs.scanMode {return false}
    if lhs.requireLocationServicesEnabled != rhs.requireLocationServicesEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceScanInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceScanInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "failure"),
    4: .same(proto: "serviceData"),
    6: .same(proto: "manufacturerData"),
    7: .same(proto: "serviceUuids"),
    5: .same(proto: "rssi"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.serviceData) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.rssi) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.manufacturerData) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.serviceUuids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.serviceData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceData, fieldNumber: 4)
    }
    if self.rssi != 0 {
      try visitor.visitSingularInt32Field(value: self.rssi, fieldNumber: 5)
    }
    if !self.manufacturerData.isEmpty {
      try visitor.visitSingularBytesField(value: self.manufacturerData, fieldNumber: 6)
    }
    if !self.serviceUuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceUuids, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceScanInfo, rhs: DeviceScanInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.serviceData != rhs.serviceData {return false}
    if lhs.manufacturerData != rhs.manufacturerData {return false}
    if lhs.serviceUuids != rhs.serviceUuids {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectToDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConnectToDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "servicesWithCharacteristicsToDiscover"),
    3: .same(proto: "timeoutInMs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._servicesWithCharacteristicsToDiscover) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timeoutInMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if let v = self._servicesWithCharacteristicsToDiscover {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.timeoutInMs != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutInMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ConnectToDeviceRequest, rhs: ConnectToDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._servicesWithCharacteristicsToDiscover != rhs._servicesWithCharacteristicsToDiscover {return false}
    if lhs.timeoutInMs != rhs.timeoutInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "connectionState"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.connectionState) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.connectionState != 0 {
      try visitor.visitSingularInt32Field(value: self.connectionState, fieldNumber: 2)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.connectionState != rhs.connectionState {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DisconnectFromDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DisconnectFromDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DisconnectFromDeviceRequest, rhs: DisconnectFromDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClearGattCacheRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClearGattCacheRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClearGattCacheRequest, rhs: ClearGattCacheRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClearGattCacheInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClearGattCacheInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClearGattCacheInfo, rhs: ClearGattCacheInfo) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotifyCharacteristicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NotifyCharacteristicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NotifyCharacteristicRequest, rhs: NotifyCharacteristicRequest) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotifyNoMoreCharacteristicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NotifyNoMoreCharacteristicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NotifyNoMoreCharacteristicRequest, rhs: NotifyNoMoreCharacteristicRequest) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReadCharacteristicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ReadCharacteristicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ReadCharacteristicRequest, rhs: ReadCharacteristicRequest) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CharacteristicValueInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CharacteristicValueInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
    2: .same(proto: "value"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CharacteristicValueInfo, rhs: CharacteristicValueInfo) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.value != rhs.value {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WriteCharacteristicRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WriteCharacteristicRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WriteCharacteristicRequest, rhs: WriteCharacteristicRequest) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WriteCharacteristicInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WriteCharacteristicInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristic"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characteristic {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WriteCharacteristicInfo, rhs: WriteCharacteristicInfo) -> Bool {
    if lhs._characteristic != rhs._characteristic {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NegotiateMtuRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NegotiateMtuRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "mtuSize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.mtuSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.mtuSize != 0 {
      try visitor.visitSingularInt32Field(value: self.mtuSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NegotiateMtuRequest, rhs: NegotiateMtuRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.mtuSize != rhs.mtuSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NegotiateMtuInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NegotiateMtuInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "mtuSize"),
    3: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.mtuSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.mtuSize != 0 {
      try visitor.visitSingularInt32Field(value: self.mtuSize, fieldNumber: 2)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NegotiateMtuInfo, rhs: NegotiateMtuInfo) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.mtuSize != rhs.mtuSize {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BleStatusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BleStatusInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BleStatusInfo, rhs: BleStatusInfo) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChangeConnectionPriorityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChangeConnectionPriorityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "priority"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.priority) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.priority != 0 {
      try visitor.visitSingularInt32Field(value: self.priority, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChangeConnectionPriorityRequest, rhs: ChangeConnectionPriorityRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.priority != rhs.priority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChangeConnectionPriorityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChangeConnectionPriorityInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChangeConnectionPriorityInfo, rhs: ChangeConnectionPriorityInfo) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CharacteristicAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CharacteristicAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "serviceUuid"),
    3: .same(proto: "characteristicUuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._serviceUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._characteristicUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if let v = self._serviceUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._characteristicUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CharacteristicAddress, rhs: CharacteristicAddress) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._serviceUuid != rhs._serviceUuid {return false}
    if lhs._characteristicUuid != rhs._characteristicUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServiceDataEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServiceDataEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuid"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceUuid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._serviceUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServiceDataEntry, rhs: ServiceDataEntry) -> Bool {
    if lhs._serviceUuid != rhs._serviceUuid {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServicesWithCharacteristics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServicesWithCharacteristics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServicesWithCharacteristics, rhs: ServicesWithCharacteristics) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServiceWithCharacteristics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServiceWithCharacteristics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceId"),
    2: .same(proto: "characteristics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._serviceID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServiceWithCharacteristics, rhs: ServiceWithCharacteristics) -> Bool {
    if lhs._serviceID != rhs._serviceID {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DiscoverServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DiscoverServicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DiscoverServicesRequest, rhs: DiscoverServicesRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DiscoverServicesInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DiscoverServicesInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DiscoverServicesInfo, rhs: DiscoverServicesInfo) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DiscoveredService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DiscoveredService"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceUuid"),
    2: .same(proto: "characteristicUuids"),
    3: .same(proto: "includedServices"),
    4: .same(proto: "characteristics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceUuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.characteristicUuids) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.includedServices) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._serviceUuid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.characteristicUuids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristicUuids, fieldNumber: 2)
    }
    if !self.includedServices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.includedServices, fieldNumber: 3)
    }
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DiscoveredService, rhs: DiscoveredService) -> Bool {
    if lhs._serviceUuid != rhs._serviceUuid {return false}
    if lhs.characteristicUuids != rhs.characteristicUuids {return false}
    if lhs.includedServices != rhs.includedServices {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DiscoveredCharacteristic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DiscoveredCharacteristic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characteristicId"),
    2: .same(proto: "serviceId"),
    3: .same(proto: "isReadable"),
    4: .same(proto: "isWritableWithResponse"),
    5: .same(proto: "isWritableWithoutResponse"),
    6: .same(proto: "isNotifiable"),
    7: .same(proto: "isIndicatable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characteristicID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._serviceID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isReadable) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isWritableWithResponse) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isWritableWithoutResponse) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isNotifiable) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isIndicatable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characteristicID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._serviceID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.isReadable != false {
      try visitor.visitSingularBoolField(value: self.isReadable, fieldNumber: 3)
    }
    if self.isWritableWithResponse != false {
      try visitor.visitSingularBoolField(value: self.isWritableWithResponse, fieldNumber: 4)
    }
    if self.isWritableWithoutResponse != false {
      try visitor.visitSingularBoolField(value: self.isWritableWithoutResponse, fieldNumber: 5)
    }
    if self.isNotifiable != false {
      try visitor.visitSingularBoolField(value: self.isNotifiable, fieldNumber: 6)
    }
    if self.isIndicatable != false {
      try visitor.visitSingularBoolField(value: self.isIndicatable, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DiscoveredCharacteristic, rhs: DiscoveredCharacteristic) -> Bool {
    if lhs._characteristicID != rhs._characteristicID {return false}
    if lhs._serviceID != rhs._serviceID {return false}
    if lhs.isReadable != rhs.isReadable {return false}
    if lhs.isWritableWithResponse != rhs.isWritableWithResponse {return false}
    if lhs.isWritableWithoutResponse != rhs.isWritableWithoutResponse {return false}
    if lhs.isNotifiable != rhs.isNotifiable {return false}
    if lhs.isIndicatable != rhs.isIndicatable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Uuid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Uuid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Uuid, rhs: Uuid) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GenericFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GenericFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GenericFailure, rhs: GenericFailure) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
